new stdout(`rho:io:stdout`), 
    stdoutAck(`rho:io:stdoutAck`),
    regInsert(`rho:registry:insertArbitrary`), 
    regLookup(`rho:registry:lookup`)
    //rs(`rho:registry:insertSigned:ed25519`) 
                                                 in {

    contract @"CoinRegistry"(return) = {
        new this, allCoins, ack in {
            stdout!("DEBUG - Created the CoinRegistry") 
            
            |
            
            allCoins!({})
                
            |
            
            contract @(*this, "createCoin")(@coin, @name, @symbol, result) = {
                stdout!("DEBUG - CoinRegistry->createCoin")
                |
                for(@coins <- allCoins){
                    if (not coins.contains(coin ++ "-name")) {
                        stdout!("DEBUG - creating a new coin")
                        |
                        allCoins!(coins.union({coin ++ "-name": name, coin ++ "-symbol": symbol}))
                        |
                        @"MakeMint"!(coin, *ack)
                        |
                        for(@mint <- ack){
                            result!(mint)
                        }
                    } else {
                        stdout!("DEBUG - coin already exists")
                        |
                        allCoins!(coins)
                        |
                        result!(Nil)
                    }
                }
            }
            
            |
            
            contract @(*this, "getCoinName")(@coin, result) = {                              
                stdout!("DEBUG - allCoins->getCoinName")
                |
                for(@coins <- allCoins){
                    if (coins.contains(coin ++ "-name")) {
                        stdout!("DEBUG - name = " ++ coins.get(coin ++ "-name")) |
                        result!(coins.get(coin ++ "-name"))
                    } else {
                        stdout!("ERROR - No coin with identifier " ++ coin) |
                        result!("ERROR")
                    }
                    |
                    allCoins!(coins)
                }
            }
            
            |
            
            contract @(*this, "getCoinSymbol")(@coin, result) = {                              
                stdout!("DEBUG - allCoins->getCoinSymbol")
                |
                for(@coins <- allCoins){
                    if (coins.contains(coin ++ "-symbol")) {
                        stdout!("DEBUG - symbol = " ++ coins.get(coin ++ "-symbol")) |
                        result!(coins.get(coin ++ "-symbol"))
                    } else {
                        stdout!("ERROR - No coin with identifier " ++ coin) |
                        result!("ERROR")
                    }
                    |
                    allCoins!(coins)
                }
            }
            
            |
            
            contract @(*this, "getAllCoins")(result) = {                              
                stdout!("DEBUG - allCoins->getAllCoins")
                |
                for(@coins <- allCoins){
                    result!(coins)
                    |
                    allCoins!(coins)
                }
            }
            
            |
    
            return!(*this)
        }
    }
    
    |
    
    contract @"CoinFaucet"(@mint, return) = {
        new this, coinAwards, ack in {    
            stdout!("DEBUG - Created the CoinFaucet") 
            
            |
            
            coinAwards!({})
    
            |
            
            contract @(*this, "createWallet")(@amount, @algorithm, @saltedHash, result) = {
                stdout!("DEBUG - CoinFaucet->createWallet")
                |
                new walletPurseCh in {
                    @(mint, "makePurse")!(amount, *walletPurseCh) 
                    |
                    for(@walletPurse <- walletPurseCh) {
                        stdout!("DEBUG - created a purse and added to a wallet")
                        |
                        @"HashWallet"!(walletPurse, algorithm, saltedHash, *result)
                        //@"BasicWallet"!(walletPurse, algorithm, publicKey, *result)
                    }
                }
            }
            
            |
            
            contract @(*this, "createCoinAward")(@purse, @saltedHash, result) = {                                
                stdout!("DEBUG - CoinFaucet->createCoinAward")
                |
                for(@awards <- coinAwards){
                    // Make sure the existing coin awards does not already contain the saltedHash
                    if (awards.contains(saltedHash)) {
                        stdout!("ERROR - coinAwards already contains the provided saltedHash")
                        |
                        coinAwards!(awards)
                        |
                        result!("ERROR - coinAwards already contains the provided saltedHash")
                    } else {
                        //C reate a HashedWallet
                        new hashWallet, registryIdentifier in {
                            @"HashWallet"!(purse, "keccak256", saltedHash, *hashWallet)
                            |
                            stdout!("DEBUG - deducted funds from the senders account")
                            |
                            for(@wallet <- hashWallet) {
                                // Add the HashedWallet to the Registry and get back its ID
                                regInsert!(wallet, *registryIdentifier) 
                                |
                                for(@{uri /\ Uri} <- registryIdentifier) {
                                    stdout!("DEBUG - registered hashWallet in the registry and added a new coinAward")
                                    |
                                    coinAwards!(awards.set(saltedHash, uri))
                                }
                                |
                                // Return the HashedWallet
                                result!(wallet)
                            }
                        }
                    }
                }
            }
            
            |
    
            contract @(*this, "redeemCoinAward")(@wallet, @saltedHash, @salt, result) = {
                stdout!("DEBUG - CoinFaucet->redeemCoinAward")
                |
                for(@awards <- coinAwards){
                    // Make sure the existing coin award exists for the saltedHash
                    if (not awards.contains(saltedHash)) {
                        stdout!("ERROR - coinAwards does not contains the provided saltedHash")
                        |
                        coinAwards!(awards)
                        |
                        result!("ERROR - coinAwards does not the provided saltedHash")
                    } else {
                        new registryID, awardWallet, awardAmount, redeemResult in {
                            // Get the registry ID for the salted hash
                            registryID!(awards.get(saltedHash))
                            |
                            for(@idForHash <- registryID){
                                stdout!("DEBUG - retrieved the registry ID for the requested saltedHash")
                                |
                                regLookup!(idForHash, *awardWallet)
                                |
                                for(@hashWallet <- awardWallet){
                                    stdout!("DEBUG - retrieved the wallet from the registry by ID")
                                    |
                                    @(hashWallet, "getBalance")!(*awardAmount)
                                    |
                                    for(@amount <- awardAmount){
                                        stdout!("DEBUG - got the award amount held in the wallet")
                                        |
                                        @(hashWallet, "transfer")!(amount, salt, wallet, *redeemResult)
                                        |
                                        for(@redeemed <- redeemResult){
                                            stdout!("DEBUG - completed the wallet redeem request")
                                            |
                                            if (redeemed == "Success"){
                                                stdout!("DEBUG - Successfully withdrew the coin award")
                                                |
                                                coinAwards!(awards.delete(saltedHash))
                                                |
                                                result!(wallet)
                                            } else {
                                                stdout!("ERROR - Failed to withdraw the coin award")
                                                |
                                                coinAwards!(awards)
                                                |
                                                result!(redeemed)
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        
            |
            
            return!(*this)
        }
    }
    
    
    
    |
    
    
    
    new coinRegistry, beerTokenMint, coinFaucet, 
        faucetWallet, faucetWalletHashOut,
        phoneWallet, phoneWalletHashOut,
        coinAwardPurse, coinAwardHashOut,
        listBalances, ack in {
            
        
        contract listBalances(@faucetWallet, @phoneWallet) = {
            new FwalletBalance, PwalletBalance in {
                @(faucetWallet, "getBalance")!(*FwalletBalance)
                |
                @(phoneWallet, "getBalance")!(*PwalletBalance)
                |
                stdoutAck!("DEBUG - listing balances", *ack)
                |
                for(@Fbalance <- FwalletBalance; @Pbalance <- PwalletBalance){
                    stdout!(Fbalance)
                    |
                    stdout!(Pbalance)
                }
            }
        }
        
        |
        
        @"CoinRegistry"!(*coinRegistry)
        |
        for(@registry <- coinRegistry) {
            @(registry, "createCoin")!("beertoken", "Beer Token", "BRTK", *beerTokenMint)
            |
            for(@mint <- beerTokenMint){
                @"CoinFaucet"!(mint, *coinFaucet)
                |
                for(@faucet <- coinFaucet){
                    @"keccak256Hash"!(["beertoken", "abc"].toByteArray(), *faucetWalletHashOut)
                    |
                    for(@faucetWalletHash <- faucetWalletHashOut){
                        stdout!("DEBUG - faucetWallet hash")
                        |
                        stdout!(faucetWalletHash)
                        |
                        @(faucet, "createWallet")!(1000, "keccak256", faucetWalletHash, *faucetWallet)
                        |
                        for(@Fwallet <- faucetWallet){
                            @"keccak256Hash"!(["beertoken", "xyz"].toByteArray(), *phoneWalletHashOut)
                            |
                            for(@phoneWalletHash <- phoneWalletHashOut){
                                stdout!("DEBUG - phoneWallet hash")
                                |
                                stdout!(phoneWalletHash)
                                |
                                @(faucet, "createWallet")!(0, "keccak256", phoneWalletHash, *phoneWallet)
                                |
                                for(@Pwallet <- phoneWallet){
                                    listBalances!(Fwallet, Pwallet)
                                    |
                                    @"keccak256Hash"!(["beertoken", "123"].toByteArray(), *coinAwardHashOut)
                                    |
                                    for(@coinAwardHash <- coinAwardHashOut){
                                        stdout!("DEBUG - coinAward hash")
                                        |
                                        stdout!(coinAwardHash)
                                        |
                                        @(Fwallet, "transfer")!(5, "abc", *coinAwardPurse, *ack)
                                        |
                                        for(@awardPurse <- coinAwardPurse){
                                            @(faucet, "createCoinAward")!(awardPurse, coinAwardHash, *ack)
                                            |
                                            for(_ <- ack){
                                                @(faucet, "redeemCoinAward")!(Pwallet, coinAwardHash, "123", *ack)
                                                |
                                                for(@redeemResult <- ack){
                                                    listBalances!(Fwallet, Pwallet)
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    
    
    
    
    
    
    |
    
    contract @"NonNegativeNumber"(@init, return) = {
        new this, valueStore in {
            contract @(*this, "add")(@x, success) = {
                if (x >= 0) {
                    for(@v <- valueStore){
                        if (v + x > v) {
                            valueStore!(v + x) | success!(true)
                        } else {
                            valueStore!(v) | success!(false) //overflow
                        }
                    }
                } else {
                    success!(false)
                }
            } 
            
            |
            
            contract @(*this, "sub")(@x, success) = {
                if (x >= 0) {
                    for(@v <- valueStore) {
                        if (x <= v) {
                            valueStore!(v - x) | success!(true)
                        } else {
                            valueStore!(v) | success!(false) //overflow
                        }
                    }
                } else {
                    success!(false)
                }
            } 
            
            |
            
            contract @(*this, "value")(return) = {
                for(@v <- valueStore) {
                    valueStore!(v) | return!(v)
                }
            } 
            
            |
            
            return!(*this) 
            
            |
            
            match init >= 0 {
                true => { valueStore!(init) }
                _ => { valueStore!(0) } //Initial balance is zero if given is negative
            }
        }
    }
    
    |
    
    contract @"MakeMint"(@coinID, return) = {
        new thisMint, totalSupplyCh, internalMakePurse, decr in {
            
            contract @(*thisMint, "makePurse")(@init, return) = {
                new balanceCh in {
                    @(*thisMint, "int2NN")!(init, *balanceCh)
                    |
                    for(@balance <- balanceCh) {
                        internalMakePurse!(balance, *return)
                        |
                        if(balance > 0){
                            for(@totalSupply <- totalSupplyCh) {
                                totalSupplyCh!(totalSupply + balance)
                            }
                        }
                    }
                }
            } 
    
            |
            
            contract @(*thisMint, "int2NN")(@x, return) = {
                new nnCh in {
                    @"NonNegativeNumber"!(x, *nnCh) 
                    | 
                    for(@nn <- nnCh) {
                        return!(nn)
                    }
                }
            } 
            
            |
            
            contract @(*thisMint, "getTotalSupply")(return) = {
                for(@totalSupply <- totalSupplyCh) {
                    totalSupplyCh!(totalSupply) | return!(totalSupply)
                }
            } 
            
            |
            
            contract internalMakePurse(@balance, return) = {
                //balance must be a name that NonNegativeNumber contract is listening on
                new thisPurse in {
                    contract @(*thisPurse, *decr)(@amount, success) = { @(balance, "sub")!(amount, *success) } 
                    
                    |
                    
                    contract @(*thisPurse, "getCoinID")(return) = { return!(coinID) }
                    
                    |
                    
                    contract @(*thisPurse, "getBalance")(return) = { @(balance, "value")!(*return) } 
                    
                    |
                    
                    contract @(*thisPurse, "sprout")(return) = { @(*thisMint, "makePurse")!(0, *return) } 
                    
                    |
                    
                    contract @(*thisPurse, "split")(@amount, return) = {
                        new destPurseCh, successCh in {
                            @(*thisPurse, "sprout")!(*destPurseCh) 
                            | 
                            for(@destPurse <- destPurseCh) {
                                @(destPurse, "deposit")!(amount, *thisPurse, *successCh) 
                                |
                                for(@success <- successCh) {
                                    if (success) {
                                        return!([destPurse])
                                    } else {
                                        return!([])
                                    }
                                }
                            }
                        }
                    } 
            
                    |
            
                    contract @(*thisPurse, "deposit")(@amount, @src, success) = {
                        new result in {
                            @(src, *decr)!(amount, *result) //call src decr function.
                            | 
                            for(@decrSuccess <- result) {
                                if (decrSuccess) {
                                    @(balance, "add")!(amount, *success) // add transferred amount to this purse
                                } else {
                                    success!(false) 
                                }
                            }
                        }
                    } 
                    
                    |
                    
                    return!(*thisPurse)
                }
            } 
            
            |
            
            totalSupplyCh!(0)
            
            |
            
            return!(*thisMint)
        }
    }

    |
    
    contract @"BasicWallet"(@purse, @algorithm, @pk, return) = {
        new cryptoVerifyCh in {
            match algorithm {
                "ed25519" => {
                    cryptoVerifyCh!(["ed25519Verify"])
                }
                "secp256k1" => {
                    cryptoVerifyCh!(["secp256k1Verify"])
                }
                _ => {
                    cryptoVerifyCh!([])
                }
            } 
            
            |
            
            for(@maybeCryptoVerify <- cryptoVerifyCh) {
                match maybeCryptoVerify {
                    []             => { return!([]) }
                    [cryptoVerify] => {
                        new basicWallet, verify, nonceCh in {
                            nonceCh!(-1) 
                            
                            |
                            
                            contract verify(@nonce, @amount, @retCh, @sig, return) = {
                                for(@prevNonce <- nonceCh) {
                                    if (nonce == (prevNonce + 1)) {
                                        new result, hashOut in {
                                            @"blake2b256Hash"!([nonce, amount, retCh].toByteArray(), *hashOut)
                                            |
                                            for(@hash <- hashOut) {
                                                @cryptoVerify!(hash, sig.hexToBytes(), pk.hexToBytes(), *result)
                                                |
                                                for(@r <- result) {
                                                    if (r) { nonceCh!(nonce) | return!(true) }
                                                    else { nonceCh!(prevNonce) | return!(false) }
                                                }
                                            }
                                        }
                                    } else {
                                        nonceCh!(prevNonce) | return!(false)
                                    }
                                }
                            } 
                            
                            |
                            
                            contract @(*basicWallet, "getNonce")(return) = {
                                for(@nonce <- nonceCh) {
                                    nonceCh!(nonce) | return!(nonce)
                                }
                            } 
                            
                            |
                            
                            contract @(*basicWallet, "getBalance")(return) = {
                                @(purse, "getBalance")!(*return)
                            } 
                            
                            |
                            
                            contract @(*basicWallet, "deposit")(@amount, @src, success) = {
                                @(purse, "deposit")!(amount, src, *success)
                            } 
                    
                            |
                            
                            contract @(*basicWallet, "transfer")(@amount, @nonce, @sig, destination, status) = {
                                new verifyResult in {
                                    verify!(nonce, amount, *destination, sig, *verifyResult) 
                                    | 
                                    for(@verified <- verifyResult) {
                                        if (verified) { 
                                            new splitResultCh in {
                                                @(purse, "split")!(amount, *splitResultCh) 
                                                |
                                                for(@splitResult  <- splitResultCh) {
                                                    match splitResult {
                                                        []        => { status!("Overdraft") }
                                                        [payment] => { destination!(payment) | status!("Success") }
                                                    }
                                                }
                                            }
                                        } else { 
                                            status!("Invalid signature or nonce") 
                                        }
                                    }
                                }
                            } 
                            
                            |
                            
                            return!([*basicWallet])
                        }
                    }
                }
            }
        }
    }

    |
    
    contract @"HashWallet"(@purse, @algorithm, @saltedHash, return) = {
        new hashCheckCh in {
            match algorithm {
                "sha256" => {
                    hashCheckCh!(["sha256Hash"])
                }
                "keccak256" => {
                    hashCheckCh!(["keccak256Hash"])
                }
                "blake2b256" => {
                    hashCheckCh!(["blake2b256Hash"])
                }
                _ => {
                    hashCheckCh!([])
                }
            } 
            
            |
            
            for(@maybeHashCheck <- hashCheckCh) {
                match maybeHashCheck  {
                    []             => { return!(Nil) }
                    [hashCheck]    => {
                        new hashWallet, checkHash in {
                            
                            contract checkHash(@salt, return) = {
                                new coinIDOut, hashOut in {
                                    @(purse, "getCoinID")!(*coinIDOut)
                                    |
                                    for(@coinID <- coinIDOut) {
                                        @hashCheck!([coinID, salt].toByteArray(), *hashOut)
                                        |
                                        for(@hash <- hashOut){
                                            if (hash == saltedHash){ return!(true)   
                                            } else { return!(false) }
                                        }
                                    }
                                }
                            }
                            
                            |
                            
                            contract @(*hashWallet, "getBalance")(return) = {
                                @(purse, "getBalance")!(*return)
                            } 
                            
                            |
                            
                            contract @(*hashWallet, "deposit")(@amount, @src, success) = {
                                @(purse, "deposit")!(amount, src, *success)
                            } 
                    
                            |
                            
                            contract @(*hashWallet, "transfer")(@amount, @salt, destination, status) = {
                                stdout!("DEBUG - HashWallet.trasfer")
                                |
                                new checkHashResult in {
                                    checkHash!(salt, *checkHashResult) 
                                    | 
                                    for(@hashIsCorrect <- checkHashResult) {
                                        if (hashIsCorrect) { 
                                            new splitResultCh in {
                                                @(purse, "split")!(amount, *splitResultCh) 
                                                |
                                                for(@splitResult  <- splitResultCh) {
                                                    match splitResult {
                                                        []        => { status!("Overdraft") }
                                                        [payment] => { destination!(payment) | status!("Success") }
                                                    }
                                                }
                                            }
                                        } else { 
                                            status!("Invalid salt for hashed wallet") 
                                        }
                                    }
                                }
                            } 
                            
                            |
                            
                            return!(*hashWallet)
                        }
                    }
                }
            }
        }
    }
    
}